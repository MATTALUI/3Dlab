<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="page-number" content="12">
  <script src="https://threejs.org/build/three.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/js/three-loaders/RGBELoader-147.js"></script>
  <script src="/js/three-loaders/GLTFLoader-147.js"></script>
  <script src="/js/three-controls/OrbitControls-146.js"></script>
  <title>Space Fighter</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -100;
    }

    nav {
      background-color: transparent;
      padding: 1rem;
      transition: background-color 500ms, border-bottom-color 500ms;
      border-bottom: 1px solid;
      border-bottom-color: rgba(255, 255, 255, 0.2);
    }

    nav a {
      text-decoration: none;
      color: rgba(255, 255, 255, 0.2);
      transition: color 500ms;
    }

    nav:hover {
      background-color: rgba(150, 150, 150, 0.2);
      border-bottom-color: aliceblue;
    }

    nav:hover a {
      color: aliceblue;
    }
  </style>
</head>

<body>
  <nav>
    <a href="/">HOME</a>
  </nav>
  <script>
    (async () => {
      const keys = {
        gamepad: null,
        up: false,
        down: false,
        left: false,
        right: false,
        firing: false,
      };

      const loaderMap = {
        abductor: {
          camera: { x: 0, y: 6, z: -20 },
          colliders: [
            { dimensions: { x: 14, y: 2, z: 14 }, position: { x: 0, y: -1, z: 0 } },
            { dimensions: { x: 10, y: 1, z: 18 }, position: { x: 0, y: -1, z: 0 } },
            { dimensions: { x: 18, y: 1, z: 10 }, position: { x: 0, y: -1, z: 0 } },
            { dimensions: { x: 6, y: 7, z: 6 }, position: { x: 0, y: 1, z: 0 } },
          ],
        },
        bomber: {},
        falcon: {
          camera: { x: 0, y: 6, z: -20 },
        },
        reactor: {},
        viper: {
          camera: { x: 0, y: 10, z: -60 },
        },
        x1: {
          colliders: [
            { dimensions: { x: 4, y: 4, z: 15.5 } },
          ],
        },
      };

      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
        if (e.key === 'ArrowUp') keys.up = true;
        if (e.key === 'ArrowDown') keys.down = true;
        if (e.key === ' ') keys.firing = true;
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
        if (e.key === 'ArrowUp') keys.up = false;
        if (e.key === 'ArrowDown') keys.down = false;
        if (e.key === ' ') keys.firing = false;
      });

      window.addEventListener("gamepadconnected", (e) => {
        console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
          e.gamepad.index, e.gamepad.id,
          e.gamepad.buttons.length, e.gamepad.axes.length);

        keys.gamepad = e.gamepad;
      });

      window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected from index %d: %s",
          e.gamepad.index, e.gamepad.id);

        keys.gamepad = null;
      });

      class Collider {
        constructor() {
          this.group = new THREE.Group();
          this.meshes = [];
          this.boxMap = {};
        }

        update() {
          this.meshes.forEach(mesh => {
            const box = this.boxMap[mesh.uuid];
            mesh.geometry.computeBoundingBox();
            box.copy(mesh.geometry.boundingBox).applyMatrix4(mesh.matrixWorld);
          });
        }

        addMesh(mesh) {
          this.meshes.push(mesh);
          this.group.add(mesh);
          this.boxMap[mesh.uuid] = new THREE.Box3();
        }

        checkCollision(collider) {
          for (const meshId in this.boxMap) {
            const box = this.boxMap[meshId];
            for (const colliderMeshId in collider.boxMap) {
              const colliderBox = collider.boxMap[colliderMeshId];
              if (box.intersectsBox(colliderBox)) return true;
            }
          }

          return false;
        }
      }

      Collider.buildColliderMesh = ({ dimensions, position }) => {
        const geometry = new THREE.BoxGeometry(
          dimensions.x,
          dimensions.y,
          dimensions.z
        );

        const wireframe = new THREE.WireframeGeometry(geometry);

        const colliderFrame = new THREE.LineSegments(wireframe);
        colliderFrame.material.depthTest = false;
        colliderFrame.material.opacity = 0.25;
        colliderFrame.material.transparent = true;

        if (position) {
          colliderFrame.position.x = position.x || 0;
          colliderFrame.position.y = position.y || 0;
          colliderFrame.position.z = position.z || 0;
        }

        return colliderFrame;
      };

      class GameObject {
        constructor(game) {
          this.game = game;
          this.group = new THREE.Group();
          this.id = this.group.uuid;
          this.collider = new Collider();
          game.scene.add(this.group);
          this.group.add(this.collider.group);
        }

        async load() { }

        update() {
          this.collider.update();
        }
      }

      class Ship extends GameObject {
        constructor(game) {
          super(game);
          this.turning = 1;
          this.speed = 0.5;
          // this.speed = 0;
          this.weaponCoolDown = 30;
          this.coolDown = 0;
          this.shipType = 'falcon';
        }

        get loaderMap() {
          return loaderMap[this.shipType] || {};
        }
      }

      class Bullet extends GameObject {
        constructor(ship) {
          super(ship.game);
          this.ship = ship;
          this.life = 150;

          const bulletMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 4, 4),
            new THREE.MeshStandardMaterial({
              roughness: 0,
              metalness: 0.25,
              color: 0xFF3300,
              emissive: 0xFF3300,
            }),
          );
          this.group.add(bulletMesh);
          this.group.add(new THREE.PointLight(0xFF3300, 1, 50));

          this.group.position.copy(ship.group.position);
          this.group.rotation.copy(ship.group.rotation);

          // Add colliders
          const geometry = new THREE.BoxGeometry(.6, .6, .6);

          const wireframe = new THREE.WireframeGeometry(geometry);

          const colliderFrame = new THREE.LineSegments(wireframe);
          colliderFrame.material.depthTest = false;
          colliderFrame.material.opacity = 0.25;
          colliderFrame.material.transparent = true;

          this.collider.addMesh(colliderFrame);
        }

        update() {
          super.update();
          this.life--;
          this.group.translateZ(3);
        }

        get isAlive() {
          const isAlive = this.life > 0;
          if (!isAlive) {
            this.game.scene.remove(this.group);
          }

          return isAlive;
        }
      }

      class PlayerShip extends Ship {
        async load() {
          // Add colliders
          (this.loaderMap.colliders || []).forEach(colliderLoadingData => {
            this.collider.addMesh(Collider.buildColliderMesh(colliderLoadingData));
          });

          await super.load();
          await new Promise((res, rej) => this.game.gltfLoader.load(
            `/models/ships/${this.shipType}.glb`,
            gltf => {
              this.group.add(gltf.scene);
              this.group.add(game.camera);

              // TODO: Calculate camera position here
              const cameraPos = this.loaderMap.camera || { x: 0, y: 6, z: -15 };
              game.camera.position.z = cameraPos.z;
              game.camera.position.y = cameraPos.y;
              game.camera.lookAt(new THREE.Vector3(0, 0, 0));
              res();
            },
            xhr => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
            console.error
          ));
        }

        update() {
          super.update();
          this.handleMovementControls();
          this.fireWeapons();
          this.group.translateZ(this.speed);
        }

        handleMovementControls() {
          // Handle main controls
          let pitchAngle = 0;
          let rollAngle = 0;
          if (keys.gamepad) {
            const deadZoneThreshold = 0.01;
            const rollValue = keys.gamepad.axes[1];
            const pitchValue = keys.gamepad.axes[2];
            if (Math.abs(rollValue) >= deadZoneThreshold) rollAngle = Utils.degToRad(rollValue);
            if (Math.abs(pitchValue) >= deadZoneThreshold) pitchAngle = Utils.degToRad(-pitchValue);
          } else {
            if (keys.up) {
              pitchAngle += Utils.degToRad(1);
            }
            if (keys.down) {
              pitchAngle -= Utils.degToRad(1);
            }
            if (keys.left) {
              rollAngle -= Utils.degToRad(1);
            }
            if (keys.right) {
              rollAngle += Utils.degToRad(1);
            }
          }

          this.group.rotateOnAxis(new THREE.Vector3(1, 0, 0), pitchAngle * this.turning);
          this.group.rotateOnAxis(new THREE.Vector3(0, 0, 1), rollAngle * this.turning);
        }

        fireWeapons() {
          const isFiring = (keys.gamepad && keys.gamepad.buttons[0].pressed) || keys.firing;
          if (this.coolDown) this.coolDown -= 1;
          if (!isFiring || this.coolDown > 0) return;
          const bullet = new Bullet(this);
          this.game.bullets.push(bullet);

          this.coolDown = this.weaponCoolDown;
        }
      }



      class Game {
        constructor() {
          // Basic THREE Initialization
          this.scene = new THREE.Scene();
          this.renderer = new THREE.WebGLRenderer();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.outputEncoding = THREE.sRGBEncoding;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          document.body.appendChild(this.renderer.domElement);
          // Camera
          this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          // Loaders
          this.pictureLoader = new THREE.RGBELoader();
          this.gltfLoader = new THREE.GLTFLoader();
          // Game objects
          this.ship = new PlayerShip(this);
          this.bullets = [];
          // Orbital Camera Controls
          // this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        }

        async loadWorld() {
          const promises = [];
          // Set background
          promises.push(new Promise((res, rej) => {
            this.pictureLoader.load("/images/hdri/space2.hdr", (texture) => {
              texture.mapping = THREE.EquirectangularReflectionMapping;
              this.scene.background = texture;
              this.scene.environment = texture;
              res();
            });
          }));
          // Load space stations
          promises.push(new Promise((res, rej) => {
            this.gltfLoader.load(
              '/models/space-station.glb',
              gltf => {
                const station = new THREE.Group();
                station.add(gltf.scene);
                station.position.x = 420;
                station.position.y = 420;
                station.position.z = 420;

                this.scene.add(station);
                res();
              },
              xhr => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
              console.error
            );
          }));
          // Load Landing Pad
          promises.push(new Promise((res, rej) => this.gltfLoader.load(
            '/models/landingpad.glb',
            gltf => {
              const pad = new THREE.Group();
              pad.add(gltf.scene);

              for (let i = 0; i < 5; i++) {
                const padCopy = pad.clone();
                padCopy.position.y = -10;
                padCopy.position.z = 10;
                padCopy.position.x = i * 200;

                this.scene.add(padCopy);
              }
              res();
            },
            xhr => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
            console.error
          )));

          await this.ship.load(this);

          return await Promise.all(promises);
        }

        run() {
          requestAnimationFrame(() => this.run());
          // this.controls.update();
          // Make Updates
          if (this.ship) this.ship.update();
          this.bullets = this.bullets.filter(bullet => {
            bullet.update();

            return bullet.isAlive;
          });

          // Check Collisions
          this.bullets.forEach(bullet => {
            if (bullet.collider.checkCollision(this.ship.collider)) {
              console.log("its colliding!");
            }
          });

          this.renderer.render(this.scene, this.camera);
        }
      }

      const game = new Game();
      await game.loadWorld();
      game.run();
    })();
  </script>
</body>

</html>