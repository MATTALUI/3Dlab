<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="page-number" content="5">
  <script src="https://threejs.org/build/three.js"></script>
  <script src="/js/three-loaders/GLTFLoader-147.js"></script>
  <script src="/js/utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
  <title>Industrial POC</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -100;
    }

    nav {
      background-color: transparent;
      padding: 1rem;
      transition: background-color 500ms, border-bottom-color 500ms;
      border-bottom: 1px solid;
      border-bottom-color: rgba(255, 255, 255, 0.2);
    }

    nav a {
      text-decoration: none;
      color: rgba(255, 255, 255, 0.2);
      transition: color 500ms;
    }

    nav:hover {
      background-color: rgba(150, 150, 150, 0.2);
      border-bottom-color: aliceblue;
    }

    nav:hover a {
      color: aliceblue;
    }

    #gui {
      position: fixed;
      /* top: 3.125rem; */
      bottom: 0;
      right: 0;
    }

    #reticle {
      position: fixed;
      top: 50%;
      right: 50%;
      /* display: inline-block; */
      display: none;
      width: 5px;
      height: 5px;
      border-radius: 100%;
      background-color: rgba(255, 255, 255, 0.25);
    }

    #player-data-collector {
      position: fixed;
      top: 40%;
      right: 25%;
      background-color: rgba(255, 255, 255, 0.25);
      width: 50%;
      padding: 1em;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border-radius: 1em;
    }

    #player-data-collector>* {
      margin-bottom: 0.5em;
    }
  </style>
</head>

<body>
  <nav>
    <a href="/">HOME</a>
  </nav>
  <span id="reticle"></span>
  <div id="player-data-collector">
    <input type="text" placeholder="Name">
    <input type="color" placeholder="Name">
    <button>Play</button>
  </div>
  <script>
    (async () => {
      // https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      const loader = new THREE.GLTFLoader();

      const renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0x999999);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Grid Helper
      scene.add(new THREE.GridHelper(50, 11));

      // Axes Helper
      scene.add(new THREE.AxesHelper(5));

      // Ambient Light
      const ambientLight = new THREE.AmbientLight(0x444444);
      scene.add(ambientLight);

      // Fog
      scene.fog = new THREE.Fog(0x999999, 0, 150);
      // scene.fog = new THREE.FogExp2(0x999999, 0.01);

      // Directional Light
      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
      scene.add(directionalLight);
      directionalLight.position.set(-80, 60, 20);

      // Directional Light Helper
      const dLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);
      scene.add(dLightHelper);

      // GUI
      const gui = new dat.GUI({ autoPlace: false });
      gui.domElement.id = 'gui';
      document.body.appendChild(gui.domElement);
      const guiOptions = {
        x: -52,
        y: 1,
        z: 133,
      };
      gui.add(guiOptions, 'x');
      gui.add(guiOptions, 'y');
      gui.add(guiOptions, 'z');

      let leftDown = false;
      let rightDown = false;
      let upDown = false;
      let downDown = false;
      let horAngle = 0;
      let vertAngle = 0;



      const canvas = document.querySelector('canvas');

      document.querySelector('#player-data-collector > button').addEventListener('click', () => {
        console.log('Yeah, you clicked!');
        const playerData = {
          name: document.querySelector('#player-data-collector > input[type="text"]').value,
          color: document.querySelector('#player-data-collector > input[type="color"]').value,
        };
        console.log(playerData);
        document.querySelector('#player-data-collector').style.display = 'none';
        document.querySelector('#reticle').style.display = 'inline-block';

        canvas.requestPointerLock = canvas.requestPointerLock ||
            canvas.mozRequestPointerLock;

        canvas.requestPointerLock();

        document.body.addEventListener('keydown', (e) => {
          // if (e.code === 'ArrowLeft') { leftDown = true; }
          // else if (e.code === 'ArrowRight') { rightDown = true; }
          if (e.code === 'ArrowUp' || e.code === 'KeyW') { upDown = true; }
          else if (e.code === 'ArrowDown' || e.code === 'KeyS') { downDown = true; }
        });
        document.body.addEventListener('keyup', (e) => {

          if (e.code === 'ArrowLeft') { leftDown = false; }
          else if (e.code === 'ArrowRight') { rightDown = false; }
          else if (e.code === 'ArrowUp' || e.code === 'KeyW') { upDown = false; }
          else if (e.code === 'ArrowDown' || e.code === 'KeyS') { downDown = false; }
        })

        // Hook pointer lock state change events for different browsers

        renderer.domElement.addEventListener('click', () => {
          // canvas.requestPointerLock = canvas.requestPointerLock ||
          //   canvas.mozRequestPointerLock;

          canvas.requestPointerLock();
        });

        const updateCamera = (e) => {
          horAngle -= e.movementX * 0.75;
          vertAngle -= e.movementY * 2;
        }

        document.addEventListener('pointerlockchange', lockChangeAlert, false);
        document.addEventListener('mozpointerlockchange', lockChangeAlert, false);

        function lockChangeAlert() {
          if (document.pointerLockElement === canvas ||
            document.mozPointerLockElement === canvas) {
            console.log('The pointer lock status is now locked');
            document.addEventListener("mousemove", updateCamera, false);
          } else {
            console.log('The pointer lock status is now unlocked');
            document.removeEventListener("mousemove", updateCamera, false);
          }
        }
      });


      // Load a glTF resource
      loader.load(
        '/models/elevator.gltf',
        gltf => {
          gltf.scene.scale.multiplyScalar(3);
          scene.add(gltf.scene);

          // gltf.animations; // Array<THREE.AnimationClip>
          // gltf.scene; // THREE.Group
          // gltf.scenes; // Array<THREE.Group>
          // gltf.cameras; // Array<THREE.Camera>
          // gltf.asset; // Object

        },
        xhr => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
        console.error
      );

      function animate() {
        requestAnimationFrame(animate);
        // Cycle horAngle
        if (leftDown) horAngle += 1;
        if (rightDown) horAngle -= 1;
        if (horAngle > 360) horAngle -= 360;
        if (horAngle < 0) horAngle += 360;
        // Clamp vertAngle
        vertAngle = Math.min(vertAngle, 90);
        vertAngle = Math.max(vertAngle, -90);

        if (upDown) {
          guiOptions.x = guiOptions.x + Math.cos(Utils.degToRad(horAngle + 90)) * 0.25;
          guiOptions.z = guiOptions.z + Math.sin(Utils.degToRad(horAngle - 90)) * 0.25;
        } else if (downDown) {
          guiOptions.x = guiOptions.x - Math.cos(Utils.degToRad(horAngle + 90)) * 0.25;
          guiOptions.z = guiOptions.z - Math.sin(Utils.degToRad(horAngle - 90)) * 0.25;
        }

        camera.rotation.y = Utils.degToRad(horAngle);
        // I don't have the math skills to figure out this gimbal lock issue
        // camera.rotation.x = Utils.degToRad(vertAngle); // Correct when vertAngle is 0 / inverted for 180;

        camera.position.set(
          guiOptions.x,
          guiOptions.y,
          guiOptions.z,
        );

        for (const controller of gui.__controllers) {
          controller.updateDisplay();
        }

        renderer.render(scene, camera);
      };

      animate();
    })();
  </script>
</body>

</html>